#include "../../../inc/Controller/Control/EditorController.hpp"
#include "../../../inc/Controller/Control/FileHandler.hpp"

EditorController::EditorController(std::optional<std::string> file_path):
    m_mode_manager{ModeType::TOOL_MODE} {

    TextFile file;
    if (!file_path.has_value() || file_path->empty()) {
        std::filesystem::path name = FileHandler::getDefaultName(); 
        file = FileHandler::createFile(name);
    }
    else {
        file = FileHandler::openFile(file_path.value());      
    }
    m_state = EditorState(file);
}

Position EditorController::getFirstVisibleChar(ScreenSize size) {
    return m_state.getFirstVisibleChar(size);
}

std::vector<std::string> EditorController::splitIntoRows(const std::string& paragraph, int start_column) const {
    if (paragraph.length() == 0) {
        return {""};
    }

    int width = m_ui_handler.screenSize().width;
    std::vector<std::string> split;
    //split.reserve((paragraph.length() - start_column) / width);

    for (int i = start_column; static_cast<size_t>(i) < paragraph.length(); i += width) {
        split.emplace_back(paragraph.substr(i, width));
    }

    return split;
}

std::vector<std::string> EditorController::calculateVisibleRows() {
    const ScreenSize size = m_ui_handler.screenSize();
    Position first_visible = getFirstVisibleChar(size);

    int current_paragraph = first_visible.row;
    std::vector<std::string> visible_rows;    
    visible_rows.reserve(size.height);

    bool is_first_paragraph = true;
    for (int visual_row = 0; visual_row < size.height;) {

        if (static_cast<size_t>(current_paragraph) < m_state.getNumberOfParagrahps()) { 
            
            std::vector<std::string> split = splitIntoRows(
                m_state.getParagraph(current_paragraph),
                (is_first_paragraph? first_visible.column : 0)
            );

            is_first_paragraph = false;


            for (const std::string& line : split) {
                visible_rows.emplace_back(line);
                visual_row++;
            }
        
            current_paragraph++;
        }        
        else {
            visible_rows.emplace_back("~"); // FUTURE: load placeholder line from settings
            visual_row++;
        }
    }
    
    return visible_rows;
}

Position EditorController::calculateScreenPositionOfCursor() {
    ScreenSize size = m_ui_handler.screenSize();

    int screen_row = std::min(
        size.height / 2,
        m_state.calculateVisualLineOfCursor(size.width)
    ); 

    int screen_column = m_state.getCursor().getColumn() % size.width;

    return {screen_row, screen_column};
}

RenderInfo EditorController::calculateRenderInfo() {
    return {
        calculateVisibleRows(),
        m_mode_manager.getModeLabel(),
        calculateScreenPositionOfCursor()
    };
}

void EditorController::mainLoop() {
    while (m_state.getIsQuit() == false) {
        RenderInfo render_info = calculateRenderInfo();
        m_ui_handler.render(render_info);
        int input = m_ui_handler.getInput();

        std::vector<std::shared_ptr<Action>> actions = m_mode_manager.convertToAction(
            input,
            m_ui_handler.screenSize()
        );

        for (std::shared_ptr action : actions) {
            action->applyTo(m_state);
        } 
    }
}